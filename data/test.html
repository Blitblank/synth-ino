<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Range-Configurable Slider</title>


    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wdth,wght@0,75..100,100..900;1,75..100,100..900&display=swap" rel="stylesheet">


    <style>
        body { 
            padding: 18px; display: flex; align-items: center; justify-content: center;
            font-family: "Roboto", sans-serif; font-optical-sizing: auto; font-weight: 500; font-style: normal; font-variation-settings: "wdth" 80;
        }

        .slider-container{ width: 100%; display: flex; align-items: center; flex-direction: row; justify-content: center; margin: 8px; gap: 10px; }
        .slider-container input{ width: 2; }
        .slider-container #slider { flex:0.2; height:20px; }

        input[type="text"], input[type="number"] {
            padding:6px 8px; border:1px solid #ccc; border-radius:6px; font-size:14px; width:40px; text-align: center;
        }

    </style>
</head>
<body>

    <div class="slider-container">
        <div class="slider-label">Frequency</div>

        <input id="minInput" class="side-input" type="text" />
        <input id="slider" type="range" />
        <input id="maxInput" class="side-input" type="text" />

        <input id="stepInput" type="text" />
        <input id="valueInput" type="text" />

    </div>

<script>
(function () {
    // elements
    const minInput = document.getElementById('minInput');
    const maxInput = document.getElementById('maxInput');
    const stepInput = document.getElementById('stepInput');
    const valueInput = document.getElementById('valueInput');
    const slider = document.getElementById('slider');

    //defaults
    let defaultMin = 0;
    let defaultMax = 100;
    let defaultStep = (defaultMax-defaultMin)/100; // 1%
    let defaultValue = 50;

    function toNumber(v, fallback = 0) {
        if (v === null || v === undefined || v === '') return fallback;
        const n = Number(String(v).trim());
        return Number.isFinite(n) ? n : fallback;
    }

    function parseStepInput(rangeMin, rangeMax) {
        const raw = String(stepInput.value || '').trim();
        if (raw.endsWith('%')) {
        const p = parseFloat(raw.slice(0, -1));
        if (!Number.isFinite(p)) return  (rangeMax - rangeMin) * 0.01; // default
        return Math.max(Number.EPSILON, (rangeMax - rangeMin) * (p / 100));
        } else {
        const n = parseFloat(raw);
        if (!Number.isFinite(n) || n <= 0) {
            // fallback to 1% of range
            return Math.max(Number.EPSILON, (rangeMax - rangeMin) * 0.01);
        }
        return n;
        }
    }

    function formatNumber(n) {
        // trim leading zeros and to 6 sig figs
        if (Number.isInteger(n)) return String(n);
        return parseFloat(n.toFixed(6)).toString();
    }

    function applyRange(min, max) {
        if (!Number.isFinite(min) || !Number.isFinite(max)) return;
        if (min >= max) {
            // update ui to reflect
            [min, max] = [Math.min(min, max), Math.max(min, max)];
        }
        slider.min = String(min);
        slider.max = String(max);

        // recompute step
        const step = parseStepInput(min, max);
        slider.step = String(step);

        // clamp current value
        let val = toNumber(slider.value, min);
        if (val < min) val = min;
        if (val > max) val = max;
        slider.value = String(val);

        // update value input display
        valueInput.value = formatNumber(Number(slider.value));
    }

    function applyStep() {
        const min = toNumber(slider.min, defaultMin);
        const max = toNumber(slider.max, defaultMax);
        const step = parseStepInput(min, max);
        slider.step = String(step);
        // update displayed value formatting
        valueInput.value = formatNumber(Number(slider.value));
    }

    // init UI with defaults
    minInput.value = String(defaultMin);
    maxInput.value = String(defaultMax);
    stepInput.value = defaultStep;
    slider.min = String(defaultMin);
    slider.max = String(defaultMax);
    slider.step = String(parseStepInput(defaultMin, defaultMax));
    slider.value = String(defaultValue);
    valueInput.value = formatNumber(defaultValue);

    // Event listeners
    minInput.addEventListener('change', () => {
        const min = toNumber(minInput.value, defaultMin);
        const max = toNumber(maxInput.value, defaultMax);
        applyRange(min, max);
    });

    maxInput.addEventListener('change', () => {
        const min = toNumber(minInput.value, defaultMin);
        const max = toNumber(maxInput.value, defaultMax);
        applyRange(min, max);
    });

    stepInput.addEventListener('change', () => {
        applyStep();
    });

    // slider updates the value input element
    slider.addEventListener('input', () => {
        valueInput.value = formatNumber(Number(slider.value));
    });

    // force value, ignores step and min/max restrictions
    function setSliderFromInput() {
        let v = valueInput.value.trim();
        if (v === '') return;
        const val = parseFloat(v);
        if (!Number.isFinite(val)) return;
        slider.value = String(val);
        valueInput.value = formatNumber(val);
    }

    valueInput.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
        ev.preventDefault();
        setSliderFromInput();
        }
    });

    // observer updates ui if the values are changes elsewhere
    const observer = new MutationObserver(() => {
        valueInput.value = formatNumber(Number(slider.value));
    });
    observer.observe(slider, { attributes: true, attributeFilter: ['value'] });

})();
</script>

</body>
</html>